<!DOCTYPE html>
<html lang="en">

</html>

<head>
    <meta charset="utf-8" />
    <link href="../styles/main.css" rel="stylesheet" />
    <title>intro page</title>
</head>

<body>
    <nav>
        <ul>
            <li><a href="java.html">Java</a></li>
            <li><a href="compArchitecture.html">Architecture</a></li>
            <li><a href="networking.html">Networking</a></li>
            <li><a href="databases.html">Databases</a></li>
            <li><a href="algorithms.html">OS</a></li>
            <li><a href="usabilityEngineering.html">Usability Eng.</a></li>
            <li><a href="algorithms.html">Algorithms</a></li>
        </ul>
    </nav>

<main>
    <section class="main">
        <h1>Welcome, this is the Algorithms module page</h1>
        <h3>Relevant coursework can be found here</h3>
    </section>
    <section id="l1" class="lectures">
        <h3>Overview of course - Lecture 1</h3>
        <p>the focus of this course is mainly on the <i>algorithms</i> , as opposed
            to the data structures,like last year - all coding is done in python again.
            Implementing the algorithms efficiently:
            <ul>
                <li>Finding the shortest path</li>
                <li>Finding trees - shortest path between nodes</li>
            </ul>
            Complexity and analysis, sorting and selecting are also <i>key</i> aims in this semester.
        </p>
    </section>
    <section id="l2" class="lectures">
        <h3>Recursive Code - Lecture 2</h3>
        <p>Some sample recursive code:</p>
            <pre><code>
            def rsum(mylist):
            If len(mylist) == 0: - base case, this is needed for recursive code to terminate
                Return 0
            Endsum = rsum(mylist[1:]) - recursively calculates the sum of the rest of the list
            Return mylist[0] + endsum
            rsum([3,5,1,8,4])
            </code></pre>
        <p>
        For <i>every</i> if statement/branch in your code, which produces a result, you <i>must</i>
        have a return statement.
        Each recursive statement in your code must get closer to the base case, so the code itself terminates.

        Best steps for Recursive code Analysis: you must understand whats happening as it is executing.
        <ul>
            <li>Count worst-case work done by a single activation, without the recursive call</li>
            <li>Count worst case number of recursive calls</li>
            <li>Multiply these two counts together</li>
        </ul>
        </p>
    </section>
    <section id="l3" class="lectures">
        <h3>Complexity Analysis - Lecture 3</h3>
        <h4>Different Notations:</h4>
        <p>
            <ul>
                <li>Big Oh - O()</li>
                <li>Big Omega - Ω()</li>
                <li>Big Theta - θ()</li>
            </ul>
            <li>Big Oh - f(n) &#60;= C*g(n), where C is some constant</li>
            Hierarchy of functions is strict, for big oh
            Find the smallest simple function that works for …..
            <li>Big Omega - Ω - f(n) is - Ω(g(n))</li>
            C*g(n) &#60;= f(n), where C is some constant, and is always better than f(n)
            <li>Big Theta - θ - f(n) is θ(g(n)) if its both big oh and big Ω</li>
            <i>Amortized Analysis - reduce, by small gradual amounts</i>
            The time used by the cpu,  c.
            The 'charge' is the amortizes cost of a single append: 3,which is O(1).
            Amortized complexity = O(1)*, the asterix shows that its the amortized complexity.
        </p>
    </section>
    <section id="l4" class="lectures">
        <h3>Sorting</h3>
        <p>
            Bubble sort-worst case complexity and swaps is O(n2)
            You may implement any sorting algorithm with a Priority Queue, which may improve the complexity of some sorts in some cases.
            <ul>
                <li>Implementing <i>selection sort</i> with th priority queue does not change its complexity,O(n2), but
                it is still faster than bubble sort.</li>
                <li>Implementing <i>insertion sort</i> with the PQ leaves a complexity of O(n) on a sorted list, however, on a n unsorted list, worst
                case complexity is again O(n2).</li>
                <li>Implementing <i>Heap sort</i> with PQ, where all action takes place with heap operations.Adding and removing items to the heap 
                is complexity O(logn), worst case to build the heap is O(nlogn).</li>
            </ul>    
        </p>
            <h3>Another  way to implement these sorting algorithms is with:</h3>
            <p>  
                <li>In place sorting</li>
                This method of sorting is restrictive, as you only sort within the memory space of the list itself.
                <ul>
                    <li>Implementing selection sort in this manner, makes the entire list the PQ, which decreases by 1 after each swap.
                    </li>
                    <li>Implementing insertion sort in this manner, PQ becomes the first part of the list, the unsorted items,the PQ grows as thr list becomes sorted.</li>
                    <li>Implementing heap sort in this manner is different to th other heaps,as you must construct a <i>max heap</i> which will grow out the PQ and shrink, when
                    sorting the list. However, in the final output you want the biggest item at the end, so we must swp the biggest item at the end.
                    <li>Complexity is O(nlogn) to build max heap and turn into a(n) (sorted) array.</li></li>
                </ul>


            </p> 

        
    </section>
<main>
</body>